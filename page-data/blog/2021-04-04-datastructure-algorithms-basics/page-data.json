{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2021-04-04-datastructure-algorithms-basics/","result":{"data":{"markdownRemark":{"html":"<h1>자료구조</h1>\n<ul>\n<li>읽기 Read - 특정 인덱스의 값을 확인하는 것</li>\n<li>검색 Search - 특정 값의 인덱스를 확인하는 것</li>\n<li>삽입 Insert</li>\n<li>삭제 Delete</li>\n</ul>\n<h1>배열 Array</h1>\n<ul>\n<li>배열 첫 항목의 메모리 주소를 기억해두기 때문에 특정 인덱스의 원소에 한번에 접근 가능</li>\n</ul>\n<h2>Big-O</h2>\n<ul>\n<li>읽기 Read - O(1)</li>\n<li>검색 Search - O(N) 뒤에 있을 수록 찾기 힘듬</li>\n<li>삽입 Insert - O(N) 뒤에 삽입하면 O(1), 최악은 맨 앞에 삽입 O(N + 1)</li>\n<li>삭제 Delete - O(N) 뒤를 삭제하면 O(1), 최악은 맨 앞을 삭제 O(N + 1)</li>\n</ul>\n<h2>Set</h2>\n<ul>\n<li>중복되는 데이터가 없음을 알려주는 자료구조</li>\n<li>읽기와 검색은 배열과 같다</li>\n<li>\n<p>삽입할 항목이 있는지 없는지 확인해야하기 때문에 모든 삽입은 먼저 검색 과정을 거친다</p>\n<ul>\n<li>마지막에 삽입하면 N + 1, 맨 앞에 삽입하면 2N + 1</li>\n</ul>\n</li>\n</ul>\n<h2>Ordered Array</h2>\n<ul>\n<li>항상 순서를 유지하는 배열</li>\n<li>\n<p>데이터 삽입시 항상 비교 과정을 거친다</p>\n<ul>\n<li>앞쪽에 삽입하면 비교를 적게 하고 대신 삽입 과정이 길다</li>\n<li>뒤쪽에 삽입하면 비교를 많이 하고 대신 삽입 과정이 짧다</li>\n</ul>\n</li>\n<li>삽입 O(N)</li>\n<li>삭제 O(1)</li>\n<li>\n<p>Linear Search는 오래 걸리지만 Binary Search 를 사용하면 O(logN)</p>\n<ul>\n<li>Ordered Array는 삽입은 느리지만 대신 검색이 매우 빠르다</li>\n</ul>\n</li>\n</ul>\n<h1>연결 리스트 Linked List</h1>\n<ul>\n<li>구조체와 포인터를 사용해 구현</li>\n<li>배열과는 달리 데이터가 메모리에 동적으로 불연속적으로 할당된다</li>\n<li>\n<p>노드에 자료와 다음 노드의 메모리 주소를 저장해 연결</p>\n<ul>\n<li>첫 노드는 head, 마지막 노드는 tail</li>\n</ul>\n</li>\n<li>head만 바로 접근이 가능</li>\n</ul>\n<h2>Big-O</h2>\n<ul>\n<li>Read - head는 O(1) tail은 O(N)</li>\n<li>Search - head는 O(1) tail은 O(N)</li>\n<li>Insert - head는 O(1) tail은 O(N + 1)</li>\n<li>Delete - head는 O(1) tail은 O(N + 1)</li>\n</ul>\n<h2>Array vs Linked List</h2>\n<table>\n<thead>\n<tr>\n<th>특징</th>\n<th>배열</th>\n<th>연결리스트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>항목 접근</td>\n<td>특정한 인덱스에 위치한 항목에 바로 접근 가능</td>\n<td>head만 바로 접근 가능</td>\n</tr>\n<tr>\n<td>메모리 할당</td>\n<td>데이터가 들어갈 공간을 미리 한번에 연속적으로 할당</td>\n<td>필요할 때마다 아무데나 할당 (동적 할당)</td>\n</tr>\n<tr>\n<td>삽입/삭제</td>\n<td>삽입/삭제 후 항목들을 shift 해야하는 번거로움</td>\n<td>해당위치까지 탐색만 했으면 O(1)으로 삽입/삭제 가능</td>\n</tr>\n<tr>\n<td>사용 예시</td>\n<td>특정한 위치의 항목에 접근이 필요한 경우</td>\n<td>한 리스트에서 삽입/삭제가 연속적으로 이루어지는 경우</td>\n</tr>\n<tr>\n<td>Reading</td>\n<td>O(1)</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>Search</td>\n<td>O(N)</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>Insertion</td>\n<td>O(N) (맨뒤는 O(1))</td>\n<td>O(N) (맨앞은 O(1))</td>\n</tr>\n<tr>\n<td>Deletion</td>\n<td>O(N) (맨뒤는 O(1))</td>\n<td>O(N) (맨앞은 O(1))</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>사실 이렇게 비교하면 연결리스트가 더 좋은게 없어보인다</li>\n<li>\n<p>하지만 하나의 리스트에서 여러번의 삭제나 삽입이 필요한 경우 연결리스트의 장점이 나타난다</p>\n<ul>\n<li>배열의 경우 탐색 + 삽입/삭제 후 항목들의 자리이동을 하는 shift과정이 필요하지만</li>\n<li>연결리스트의 경우 탐색 + O(1)의 삽입/삭제만 있으면 된다</li>\n</ul>\n</li>\n<li>e.g. 1000개의 메일 주소가 있고 그 중 100개의 스팸메일을 지우는 작업</li>\n</ul>\n<h3>양방향 연결 리스트 Doubly Linked List</h3>\n<ul>\n<li>양방향 연결 리스트는 이전 노드와 다음 노드의 메모리 주소를 동시에 갖고 있다</li>\n<li>따라서 첫 노드와 마지막 노드의 메모리 주소를 기억하고 있어 맨앞과 맨뒤 항목에 바로 접근이 가능하다</li>\n<li>큐를 구현하기에 좋은 자료구조</li>\n</ul>\n<h2>큐 Queue</h2>\n<ul>\n<li>\n<p>추상적 자료구조 - 이론적인 규칙들의 모음으로 다른 자료구조를 사용해 구현하는 형태의 자료구조</p>\n<h3>특징</h3>\n</li>\n<li>FIFO (First-in First-out)</li>\n<li>삽입시 맨뒤에 추가</li>\n<li>삭제시 맨앞을 삭제</li>\n<li>맨앞만 읽을 수 있음</li>\n</ul>\n<pre class=\"grvsc-container github-light-theme grvsc-ps-t4tStz\" data-language=\"python\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">class</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-10 grvsc-t4tStz-5\">Node</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">def</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-1\">__init__</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">(</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-6\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">, </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-6\">data</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">):</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">    </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-1\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">.data </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> data</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">class</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> DoublyLinkedList</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">def</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-1\">__init__</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">(</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-6\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">, )</span></span></span></code></pre>\n<h2>Stack 스택</h2>\n<ul>\n<li>\n<p>추상적 자료구조</p>\n<h3>특징</h3>\n</li>\n<li>LIFO (Last-in First-out)</li>\n<li>삽입시 맨뒤에 추가</li>\n<li>삭제시 맨뒤를 삭제</li>\n<li>맨뒤만 읽을 수 있음</li>\n</ul>\n<h3>활용예시</h3>\n<ul>\n<li>웹 브라우저 방문기록 (뒤로가기) - 가장 나중에 열린 페이지부터 보여주기</li>\n<li>실행 취소 (undo) - 가장 나중에 실행된 것부터 실행 취소</li>\n</ul>\n<h2>Dequq 데크 Double Ended Queue</h2>\n<ul>\n<li>양끝에 삽입과 삭제가 가능</li>\n</ul>\n<h1>Tree</h1>\n<ul>\n<li>사이클이 존재하지 않고 모든 노드들이 연결된 그래프</li>\n<li>노드로 이루어진 자료구조로 하나의 노드가 여러개의 노드에 연결되어 있을 수 있다</li>\n<li>레벨, 부모와 자식, 균형</li>\n</ul>\n<h2>Tree Traversal</h2>\n<ul>\n<li>Inorder - 왼쪽부터 오른쪽으로 방문</li>\n<li>Preorder - 부모 -> 왼쪽 -> 오른쪽 순으로 방문 (부모를 방문했으면 그 다음으로 무조건 왼쪽 자식을 방문해야함)</li>\n<li>Postorder - 왼쪽 -> 오른쪽 -> 부모 순으로 방문</li>\n</ul>\n<h2>Binary Tree</h2>\n<ul>\n<li>노드가 최대 두 개인 트리</li>\n</ul>\n<h3>Complete, Perfect, Full</h3>\n<ul>\n<li>Complete - 구멍이 없는 것. 모든 노드가 왼쪽부터 쌓여있는 것 (오른쪽 노드가 비어있을 수 있음)</li>\n<li>Perfect - 모든 자식이 차 있는 것. 모든 레벨이 꽉 차 있는 것.</li>\n<li>Full - 부모가 두 개의 자식이 있거나 아예 자식이 없는 경우</li>\n</ul>\n<h2>Binary Search Tree</h2>\n<ul>\n<li>각 노드는 최대 2개의 노드를 가질 수 있다</li>\n<li>왼쪽 자식 &#x3C; 부모 &#x3C; 오른쪽 자식</li>\n<li>삽입/삭제 후에도 항상 순서를 유지하고 검색이 용이한 자료구조</li>\n</ul>\n<h2>Big-O</h2>\n<ul>\n<li>\n<p>Search - O(log N)</p>\n<ul>\n<li>크면 오른쪽 작으면 왼쪽</li>\n</ul>\n</li>\n<li>\n<p>Insertion - O(log N)</p>\n<ul>\n<li>검색보다 하나의 스텝이 더 필요</li>\n<li>완전히 불균형할 경우 O(N)</li>\n</ul>\n</li>\n<li>\n<p>Deletion - O(log N)</p>\n<ul>\n<li>검색 후 삭제 과정이 추가</li>\n<li>자식이 없는 노드면 바로 삭제</li>\n<li>자식이 있는 노드면 해당 노드보다 큰값을 가진 노드 중 가장 작은 것으로 교체 (successor node)</li>\n</ul>\n</li>\n</ul>\n<h1>Binary Heap</h1>\n<ul>\n<li>weakly ordered하다</li>\n<li>max heap의 heap condition: 모든 부모 노드는 자손 노드들보다 값이 커야한다</li>\n<li>트리가 무조건 complete해야한다</li>\n<li>\n<p>배열의 자료가 많으면 마지막 노드 접근이 오래걸린다는 문제를 해결하기 위해 배열로 구현한다</p>\n<ul>\n<li>각 노드에 인덱스를 부여</li>\n<li>마지막 노드는 항상 마지막 인덱스</li>\n</ul>\n</li>\n</ul>\n<h2>Big-O</h2>\n<ul>\n<li>삽입 O(log N)</li>\n<li>삭제 O(log N)</li>\n</ul>\n<h2>Traversing</h2>\n<ul>\n<li>왼쪽 자식 인덱스 = (부모의 인덱스 * 2) + 1</li>\n<li>오른쪽 자식 인덱스 = (부모의 인덱스 * 2) + 2</li>\n<li>부모의 인덱스 = (자식의 인덱스 - 1) / 2</li>\n</ul>\n<h2>Priority Queue</h2>\n<ul>\n<li>삭제와 접근은 일반 큐와 같지만 삽입은 정렬 리스트 ordered array 와 같은 자료구조</li>\n<li>맨앞만 삭제 가능</li>\n<li>맨앞만 읽기 가능</li>\n<li>\n<p>자료를 삽입해도 항상 순서 유지</p>\n<ul>\n<li>e.g. 병동에서 부상의 정도에 따라 진료 순서를 정해놓는 경우 (triage system)</li>\n</ul>\n</li>\n</ul>\n<h3>Priority Queue를 Heap으로</h3>\n<ul>\n<li>heap은 priority queue에 적합한 자료구조</li>\n<li>가장 우선순위가 높은 항목에 바로 접근 가능</li>\n<li>삽입과 삭제가 O(log N) 이라는 빠른 시간에 가능</li>\n</ul>\n<h3>Priority Queue Big-O</h3>\n<ul>\n<li>삭제 O(1), 삽입 O(N)</li>\n<li>\n<p>자료가 많은 경우 마지막 노드 접근이 너무 오래 걸리는 문제 발생</p>\n<ul>\n<li>heap으로 구현하면 문제 해결</li>\n</ul>\n</li>\n</ul>\n<h1>BST vs Heap</h1>\n<table>\n<thead>\n<tr>\n<th>자료구조</th>\n<th>Ordered Array</th>\n<th>Binary Search Tree</th>\n<th>Heap</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Search</td>\n<td>O(log N)</td>\n<td>O(log N)</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>Insertion</td>\n<td>O(N)</td>\n<td>O(log N)</td>\n<td>O(log N)</td>\n</tr>\n<tr>\n<td>Deletion</td>\n<td>O(1)</td>\n<td>O(log N)</td>\n<td>O(log N)</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Heap은 가장 우선순위가 높은 항목에 대해서만 탐색이 O(1)</li>\n<li>Heap은 priority queue에 적합한 자료구조</li>\n<li>BST는 Heap과 다르게 항상 completely balanced되어있지 않기 때문에 최악의 경우 탐색이 O(N)</li>\n</ul>\n<h1>정렬 Sort</h1>\n<table>\n<thead>\n<tr>\n<th>Sort</th>\n<th>Best Case</th>\n<th>Average Case</th>\n<th>Worst Case</th>\n<th>공간 복잡도</th>\n<th>stability</th>\n<th>방법</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bubble Sort</td>\n<td>O(N)</td>\n<td>O(N<sup>2</sup>)</td>\n<td>O(N<sup>2</sup>)</td>\n<td>O(1)</td>\n<td>stable</td>\n<td>둘씩 비교</td>\n</tr>\n<tr>\n<td>Insertion Sort</td>\n<td>O(N)</td>\n<td>O(N<sup>2</sup>)</td>\n<td>O(N<sup>2</sup>)</td>\n<td>O(1)</td>\n<td>stable</td>\n<td>왼쪽들과 비교</td>\n</tr>\n<tr>\n<td>Merge Sort</td>\n<td>O(N log N)</td>\n<td>O(N log N)</td>\n<td>O(N log N)</td>\n<td>O(N)</td>\n<td>stable</td>\n<td>둘씩 묶어서 정렬</td>\n</tr>\n<tr>\n<td>Selection Sort</td>\n<td>O(N<sup>2</sup>)</td>\n<td>O(N<sup>2</sup>)</td>\n<td>O(N<sup>2</sup>)</td>\n<td>O(1)</td>\n<td>unstable</td>\n<td>매단계 최솟값 탐색</td>\n</tr>\n<tr>\n<td>Heap Sort</td>\n<td>O(N log N)</td>\n<td>O(N log N)</td>\n<td>O(N log N)</td>\n<td>O(1)</td>\n<td>unstable</td>\n<td>힙에 모두 삽입 후 모두 삭제</td>\n</tr>\n<tr>\n<td>Quick Sort</td>\n<td>O(N log N)</td>\n<td>O(N log N)</td>\n<td>O(N<sup>2</sup>)</td>\n<td>O(N log N)</td>\n<td>unstable</td>\n<td>pivot과 left pointer, right pointer</td>\n</tr>\n</tbody>\n</table>\n<h2>버블 정렬 Bubble Sort</h2>\n<ul>\n<li>나란히 있는 항목 둘씩 비교</li>\n<li>순서가 바뀌어있으면 스왑으로 자리 바꿈</li>\n<li>모든 숫자들을 끝까지 비교했으면 다시 처음부터 반복</li>\n<li>O(N<sup>2</sup>)</li>\n</ul>\n<h2>삽입 정렬 Insertion Sort</h2>\n<ul>\n<li>인덱스 1부터 항목을 선택</li>\n<li>선택한 항목과 그 항목의 왼쪽 항목들을 비교</li>\n<li>선택한 항목이 더 작으면 스왑 (왼쪽 항목들 중 선택항목보다 크면서 가장 작은 것과 스왑)</li>\n<li>다음 인덱스 항목을 선택해서 또 반복</li>\n<li>\n<p>O(N<sup>2</sup>)</p>\n<ul>\n<li>Best Case - O(N) - 이미 원하는대로 정렬된 경우</li>\n<li>Average Case - O(N<sup>2</sup>/2)</li>\n<li>Worst Case - O(N<sup>2</sup>) - 반대로 정렬된 경우 매 단계마다 스왑</li>\n</ul>\n</li>\n</ul>\n<h2>병합 정렬 Merge Sort</h2>\n<ul>\n<li>항목들을 둘씩 묶어 각 묶음 내에서 정렬</li>\n<li>묶음을 또 두개씩 묶어 하나의 묶음 내에서 정렬</li>\n<li>시간복잡도 O(log N)</li>\n<li>공간복잡도 O(N)</li>\n</ul>\n<h2>선택 정렬 Selection Sort</h2>\n<ul>\n<li>매 단계 최솟값과 첫 항목의 위치를 바꾼다</li>\n<li>스왑 후 다음 항목으로 넘어간다</li>\n<li>매 단계 0번이나 한번의 스왑을 진행</li>\n<li>\n<p>O(N<sup>2</sup>) - 버블 정렬보다 두 배 가량 빠르지만 그래도 O(N<sup>2</sup>)</p>\n<ul>\n<li>Best Case - O(N<sup>2</sup>/2) - 이미 원하는대로 정렬된 경우</li>\n<li>Average Case - O(N<sup>2</sup>/2)</li>\n<li>Worst Case - O(N<sup>2</sup>/2) - 반대로 정렬된 경우 모두 비교 후 전부 자리이동</li>\n</ul>\n</li>\n</ul>\n<h2>힙 정렬 Heap Sort</h2>\n<ul>\n<li>하나씩 힙에 삽입한 후 가장 큰 것부터 차례대로 삭제해서 정렬 (max heap)</li>\n<li>O(N log N)</li>\n</ul>\n<h2>퀵 정렬 Quick Sort</h2>\n<ul>\n<li>partition과 재귀를 사용한 정렬</li>\n<li>\n<p>O(N log N)</p>\n<ul>\n<li>매 단계 반으로 쪼개져서 logN 단계</li>\n<li>각 단계마다 N번 비교</li>\n<li>Best Case - O(N log N)</li>\n<li>Average Case - O(N log N)</li>\n<li>Worst Case - O(N<sup>2</sup>) - pivot이 항상 끝에 위치</li>\n</ul>\n</li>\n</ul>\n<h3>Partition</h3>\n<ul>\n<li>pivot을 하나 골라 pivot보다 작은 값들은 pivot의 왼쪽, 큰 값들은 pivot의 오른쪽에 위치하게 하는 것</li>\n</ul>\n<h3>Quick Select</h3>\n<ul>\n<li>정렬은 필요없지만 특정 순위의 값을 알고싶은 경우 사용</li>\n<li>Quick 정렬과 Binary Search 사용</li>\n<li>O(N)</li>\n</ul>\n<h1>Stable vs Unstable</h1>\n<ul>\n<li>\n<p>같은 값을 가진 항목들의 순서를 유지하는지 안 하는지</p>\n<ul>\n<li>Stable - 같은 값을 가진 항목들의 순서가 정렬 후에도 유지되는 것</li>\n<li>Unstable - 같은 값을 가진 항목들의 순서가 정렬 후에도 유지되지 않는 것</li>\n</ul>\n</li>\n<li>같은 값을 가진 항목들을 구분해야할 때 stable한 정렬이 필요</li>\n<li>e.g. 학생 이름과 성적이 있을 때 성적순으로 정렬. 하지만 기존 이름 순서는 보존하고 싶은 경우 stable한 정렬을 사용해야 한다 <a href=\"https://www.freecodecamp.org/news/stability-in-sorting-algorithms-a-treatment-of-equality-fa3140a5a539/\">그림 출처</a>\n<img src=\"https://user-images.githubusercontent.com/52592748/113816883-6cc7be00-97b0-11eb-9755-776d4bab28c8.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/52592748/113816896-705b4500-97b0-11eb-94ec-b00b003e4263.png\" alt=\"image\"></li>\n</ul>\n<h2>Stable Sort</h2>\n<ul>\n<li>버블 정렬 Bubble Sort</li>\n<li>삽입 정렬 Insertion Sort</li>\n<li>병합 정렬 Merge Sort</li>\n</ul>\n<h2>Unstable Sort</h2>\n<ul>\n<li>선택 정렬 Selection Sort</li>\n<li>퀵 정렬 Quick Sort</li>\n<li>힙 정렬 Heap Sort</li>\n</ul>\n<h1>Hash Table</h1>\n<ul>\n<li>hash function으로 키를 인덱스로 변경</li>\n<li>검색: O(1)</li>\n<li>hash function에 다른 인풋을 넣었는데 같은 아웃풋이 나오면 collision이 발생</li>\n</ul>\n<h2>Collsion 해결법</h2>\n<ul>\n<li>Open Addressing과 Separate Chaining 모두 O(m)</li>\n<li>Open Addressing은 연속된 공간에 저장해서 캐시 효율이 높다 (데이터 개수가 적으면 효율이 굳)</li>\n<li>Separate Chaining은 테이블의 확장을 늦출 수 있다</li>\n</ul>\n<h3>1. Open Addressing (개방주소법)</h3>\n<ul>\n<li>충돌 발생시 다른 해시 버킷 (다른 위치)에 저장</li>\n<li>\n<p>해시 버킷이 많이 차있을수록 Worst Case발생 빈도가 높아진다</p>\n<ul>\n<li>Worst Case: 비어있는 버킷을 못 찾아 탐색시작위치에 돌아오는 것</li>\n</ul>\n</li>\n<li>Linear Probing - 순차적으로 탐색</li>\n<li>Quadratic Probing - 2차 함수를 이용해 탐색 (키를 i^2순으로 증가)</li>\n<li>Double Hashing Probing - 다른 해시 함수를 이용 (연산이 많이 필요해짐)</li>\n</ul>\n<h3>2. Separate Chaining (분리 연결법)</h3>\n<ul>\n<li>Open Addressing보다 빠르다</li>\n<li>데이터가 적으면(키-값 쌍이 6~7개까지) 연결리스트를 사용하는 것이 오버헤드가 적다 트리는 메모리 사용량이 많기 때문</li>\n<li>Linked List - 버킷들을 연결리스트로 만든다. Collsion 발생시 해당 버킷의 리스트에 추가</li>\n<li>Red-Black Tree - 버킷들을 트리에 저장</li>\n</ul>\n<h1>Trie</h1>\n<ul>\n<li>autocomplete와 같은 기능을 위해 단어를 저장하는데 최적</li>\n<li>다른 노드들을 가리키는 노드들의 집합</li>\n<li>자식 노드 개수의 제한이 없음</li>\n</ul>\n<h2>Big-O</h2>\n<ul>\n<li>\n<p>검색: O(K) </p>\n<ul>\n<li>K: 문자열의 길이, 속도는 단어의 수 N에 비례</li>\n</ul>\n</li>\n</ul>\n<h2>구현</h2>\n<ul>\n<li>\n<p>노드 클래스 - 각 노드는 해시 테이블을 지님 (키: 자식의 알파벳, 값: 트라이 노드 인스턴스)</p>\n<ul>\n<li>단어의 끝을 나타내기 위해 값으로 * 을 저장</li>\n</ul>\n</li>\n<li>트라이 클래스 - 루트 노드 값을 저장하고 트라이 메소드를 지님</li>\n</ul>\n<pre class=\"grvsc-container github-light-theme grvsc-ps-t4tStz\" data-language=\"python\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">class</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-10 grvsc-t4tStz-5\">TrieNode</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">def</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-1\">__init__</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">(</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-6\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">):</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">    </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-1\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">.children </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> {}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">class</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-10 grvsc-t4tStz-5\">Trie</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">def</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-1\">__init__</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">(</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-6\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">):</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">    </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-1\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">.root </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> TrieNode()</span></span></span></code></pre>\n<h2>검색 Search</h2>\n<ul>\n<li>어떤 문자열이 트라이내 단어의 prefix인지</li>\n<li>currentNode 생성 후 루트로 초기화</li>\n<li>문자열의 문자마다 반복문</li>\n<li>currentNode가 해당 문자를 자식으로 갖는지 확인</li>\n<li>안 가지면 return None</li>\n<li>가지면 currentNode를 자식으로 업데이트 후 다음 문자로 넘어감</li>\n<li>문자열의 끝에 도달했다면 return currentNode</li>\n</ul>\n<pre class=\"grvsc-container github-light-theme grvsc-ps-t4tStz\" data-language=\"python\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">def</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-10 grvsc-t4tStz-5\">search</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">(</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-6\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">, </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-6\">word</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">):</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  currentNode </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-1\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">.root</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">for</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> char </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">in</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> word:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">    </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">if</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> currentNode.children.get(char):</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">      currentNode </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> currentNode.children[char]</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">    </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">else</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">      </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">return</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-3\">None</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">return</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> currentNode</span></span></span></code></pre>\n<h2>삽입 Insert</h2>\n<ol>\n<li>currentNode 생성 후 루트로 초기화</li>\n<li>문자열의 문자마다 반복문</li>\n<li>currentNode가 해당 문자를 자식으로 갖는지 확인</li>\n<li>가지면 currentNode를 자식으로 업데이트 후 다음 문자로 넘어감</li>\n<li>안 가지면 currentNode가 해당 자식을 갖도록 하고 currentNode를 새로운 자식으로 업데이트 후 다음 문자로 넘어감</li>\n<li>마지막 문자를 삽입 후 *을 자식으로 삽입해 문자열이 끝났음을 알림</li>\n</ol>\n<pre class=\"grvsc-container github-light-theme grvsc-ps-t4tStz\" data-language=\"python\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">def</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-10 grvsc-t4tStz-5\">insert</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">(</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-6\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">, </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-6\">word</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">):</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  currentNode </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-1\">self</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">.root</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">for</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> char </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">in</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> word:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">    </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">if</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> currentNode.children.get(char):</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">      currentNode </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> currentNode.children[char]</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">    </span><span class=\"grvsc-tiszgT-5 grvsc-t4tStz-9\">else</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">      currentNode.children[char] </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> TrieNode()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">      currentNode </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> currentNode.children[char]</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">  currentNode.children[</span><span class=\"grvsc-tiszgT-8 grvsc-t4tStz-10\">&quot;*&quot;</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">] </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-3\">None</span></span></span></code></pre>\n<h1>그래프 Graph</h1>\n<ul>\n<li>데이터들이 어떻게 연결되어있는지, 관계에 최적화된 자료구조</li>\n<li>정점 (vertices)와 간선 (edges)로 이루어짐</li>\n<li><strong>connected graph</strong> - 모든 노드가 직간접적으로 연결</li>\n<li><strong>directed graph</strong> - 관계가 단방향</li>\n<li><strong>undirected graph</strong> - 양방향</li>\n<li><strong>spanning tree</strong> - 정점들이 최소한의 간선으로 연결된 그래프</li>\n</ul>\n<h2>그래프 표현방법</h2>\n<ul>\n<li>\n<p>Adjacency List - n번 노드와 연결된 모든 노드들을 배열의 n번째에 배열로 넣는다</p>\n<ul>\n<li>\n<p>e.g. 1번 노드와 연결된 노드들이 2, 3, 5번 노드라면 배열의 1번째 인덱스의 배열에 2, 3, 5를 삽입</p>\n<pre class=\"grvsc-container github-light-theme grvsc-ps-t4tStz\" data-language=\"python\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">[</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">[],</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">[</span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-3\">2</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">, </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-3\">3</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">, </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-3\">5</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">],</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">[],</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-3\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">]</span></span></span></code></pre>\n</li>\n</ul>\n</li>\n<li>Adjacency Matrix - <code>adj[i][j]</code>에 i번 노드부터 j번 노드까지 방향이 존재하면 1, 없으면 0 삽입</li>\n</ul>\n<h2>검색 Search</h2>\n<ul>\n<li>특정 정점을 찾거나 하나의 정점부터 다른 정점까지 지나가는 목적으로 검색</li>\n<li>그래프 탐색의 핵심은 지나간 정점을 기록하는 것 (사이클을 가질 수 있기에 무한 사이클 방지)</li>\n</ul>\n<h3>Depth-First Search DFS</h3>\n<ul>\n<li>재귀를 사용한 탐색 방법</li>\n<li>랜덤한 정점에서 시작</li>\n<li>현재 정점을 visited 해시에 저장</li>\n<li>adjacent한 정점들 방문</li>\n<li>이미 방문한 곳이면 무시</li>\n<li>처음 방문하는 곳이면 그 정점의 adjacent한 정점들 방문</li>\n</ul>\n<h3>Breadth-First Search BFS</h3>\n<ul>\n<li>큐를 사용한 탐색 방법</li>\n<li>랜덤한 정점에서 시작</li>\n<li>시작 정점을 visited 해시에 저장</li>\n<li>시작 정점을 queue에 저장</li>\n<li>queue가 비어있지 않은 동안 반복문 실행</li>\n<li>queue의 첫 정점을 제거 후 현재 정점으로 설정</li>\n<li>현재 정점의 adjacent한 정점들 방문</li>\n<li>이미 방문한 곳이면 무시</li>\n<li>처음 방문하는 곳이면 visited에 기록 후 queue에 추가</li>\n<li>4번부터 반복</li>\n</ul>\n<h2>Big-O</h2>\n<p>O(V + E)</p>\n<h2>Dijkstra's Algorithm</h2>\n<ul>\n<li>Weighted graph에서 Shortest Path Problem 해결을 위한 방법 중 하나</li>\n<li>O(V<sup>2</sup>)</li>\n<li>\n<ul>\n<li>visited hash table</li>\n<li>(cost/distance, adjacent vertex) queue</li>\n<li>cost/distance hash table</li>\n</ul>\n</li>\n</ul>\n<h1>동적 프로그래밍 Dynamic Programming</h1>\n<ul>\n<li>\n<p>재귀함수를 사용하는 경우 overlapping subproblems를 해결하는 방식</p>\n<ul>\n<li>한 문제를 해결하기 위해 해결해야하는 더 작은 문제를 subproblem이라 한다</li>\n<li>이 때, 똑같은 subproblem을 반복적으로 풀어야한다면 overlapping subproblems이 발생</li>\n<li>O(2<sup>N</sup>)</li>\n</ul>\n</li>\n</ul>\n<h2>Memoization</h2>\n<ul>\n<li>이전에 실행한 값을 기억해 반복작업을 제한하는 방식</li>\n<li>피보나치 수열을 구하는 문제의 경우 해시 테이블에 계산한 값들을 저장해둔다</li>\n<li>O(N)</li>\n</ul>\n<h2>Bottom-Up</h2>\n<ul>\n<li>반복문으로 푸는 방식</li>\n<li>O(N)</li>\n<li>\n<p>피보나치 예시: 0, 1부터 계산을 시작</p>\n<pre class=\"grvsc-container github-light-theme grvsc-ps-t4tStz\" data-language=\"python\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">a </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-3\">0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\">b </span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-9\">=</span><span class=\"grvsc-tiszgT-1 grvsc-t4tStz-1\"> </span><span class=\"grvsc-tiszgT-7 grvsc-t4tStz-3\">1</span></span></span></code></pre>\n</li>\n</ul>\n<p>for _ in range(1, n):\ntemp = a\na = b\nb = temp + a</p>\n<pre><code></code></pre>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .github-light-theme {\n    background-color: #ffffff;\n    color: #000000;\n  }\n  .github-light-theme .grvsc-tiszgT-5 { color: #D73A49; }\n  .github-light-theme .grvsc-tiszgT-1 { color: #000000; }\n  .github-light-theme .grvsc-tiszgT-10 { color: #6F42C1; }\n  .github-light-theme .grvsc-tiszgT-7 { color: #005CC5; }\n  .github-light-theme .grvsc-tiszgT-8 { color: #032F62; }\n  .github-light-theme .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(0, 0, 0, 0.05));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(0, 0, 0, 0.2));\n  }\n  body[data-theme=dark] .grvsc-ps-t4tStz { color: #ffffff; }\n  body[data-theme=dark] .grvsc-ps-t4tStz .grvsc-t4tStz-9 { color: #EB7E81; }\n  body[data-theme=dark] .grvsc-ps-t4tStz .grvsc-t4tStz-1 { color: #FFFFFF; }\n  body[data-theme=dark] .grvsc-ps-t4tStz .grvsc-t4tStz-5 { color: #BB97E7; }\n  body[data-theme=dark] .grvsc-ps-t4tStz .grvsc-t4tStz-6 { color: #F39961; }\n  body[data-theme=dark] .grvsc-ps-t4tStz .grvsc-t4tStz-3 { color: #66B5F6; }\n  body[data-theme=dark] .grvsc-ps-t4tStz .grvsc-t4tStz-10 { color: #9DCDF5; }\n  body[data-theme=dark] .grvsc-ps-t4tStz .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(0, 0, 0, 0.05));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(0, 0, 0, 0.2));\n  }\n</style>","frontmatter":{"title":"Data Structures and Algorithms basics","desc":"Jay Wengrow의 A Common-Sense Guide to Data Structures and Algorithms","thumbnail":{"childImageSharp":{"fixed":{"src":"/static/b4e70f9bc2c95ecbdc8536879878a910/2244e/thumbnail.jpg"}}},"date":"2021-04-04","category":"Algorithm"}}},"pageContext":{"slug":"/blog/2021-04-04-datastructure-algorithms-basics/"}},"staticQueryHashes":["1990743003"]}